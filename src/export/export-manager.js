/**
 * Export Manager
 * Handles exporting test data and scripts in multiple formats
 */

class ExportManager {
  constructor() {
    this.supportedFormats = ['json', 'csv', 'markdown', 'html'];
  }

  /**
   * Export actions and script in specified format
   */
  exportData(data, format, options = {}) {
    const exporters = {
      json: () => this.exportToJSON(data, options),
      csv: () => this.exportToCSV(data, options),
      markdown: () => this.exportToMarkdown(data, options),
      html: () => this.exportToHTML(data, options)
    };

    const exporter = exporters[format.toLowerCase()];
    if (!exporter) {
      throw new Error(`Unsupported export format: ${format}`);
    }

    return exporter();
  }

  /**
   * Export to JSON format
   */
  exportToJSON(data, options = {}) {
    const exportData = {
      metadata: {
        exportDate: new Date().toISOString(),
        framework: data.framework || 'playwright',
        totalActions: data.actions?.length || 0,
        exportVersion: '1.0.0',
        ...options.metadata
      },
      actions: data.actions || [],
      script: data.script || '',
      settings: data.settings || {},
      networkRequests: data.networkRequests || []
    };

    // Include optional data if present
    if (data.pageObjects) {
      exportData.pageObjects = data.pageObjects;
    }
    if (data.cicdConfig) {
      exportData.cicdConfig = data.cicdConfig;
    }
    if (data.assertions) {
      exportData.assertions = data.assertions;
    }

    const jsonString = JSON.stringify(exportData, null, 2);

    return {
      content: jsonString,
      filename: this.generateFilename('flowscribe-export', 'json', options),
      mimeType: 'application/json'
    };
  }

  /**
   * Export to CSV format (actions summary)
   */
  exportToCSV(data, options = {}) {
    const actions = data.actions || [];

    // CSV headers
    const headers = [
      'Step',
      'Action Type',
      'Element',
      'Value',
      'URL',
      'Timestamp',
      'Selector'
    ];

    // CSV rows
    const rows = actions.map((action, index) => {
      const element = action.element || action.target || {};

      return [
        index + 1,
        action.type || '',
        this.getElementDescription(element),
        action.value || '',
        action.url || '',
        action.timestamp ? new Date(action.timestamp).toISOString() : '',
        element.cssSelector || element.xpath || ''
      ];
    });

    // Build CSV string
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => this.csvEscape(cell)).join(','))
    ].join('\n');

    return {
      content: csvContent,
      filename: this.generateFilename('flowscribe-actions', 'csv', options),
      mimeType: 'text/csv'
    };
  }

  /**
   * Export to Markdown format (test documentation)
   */
  exportToMarkdown(data, options = {}) {
    const actions = data.actions || [];
    const framework = data.framework || 'playwright';
    const script = data.script || '';

    let markdown = `# FlowScribe Test Documentation\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Framework:** ${framework}\n`;
    markdown += `**Total Actions:** ${actions.length}\n\n`;

    markdown += `---\n\n`;

    // Test Overview
    markdown += `## Test Overview\n\n`;
    markdown += `This test was automatically generated by FlowScribe from recorded user interactions.\n\n`;

    // Actions Summary
    markdown += `## Recorded Actions\n\n`;
    markdown += `| Step | Action | Element | Value | URL |\n`;
    markdown += `|------|--------|---------|-------|-----|\n`;

    actions.forEach((action, index) => {
      const element = action.element || action.target || {};
      const elementDesc = this.getElementDescription(element);
      const value = action.value || '-';
      const url = this.formatUrlForMarkdown(action.url) || '-';

      markdown += `| ${index + 1} | ${action.type} | ${elementDesc} | ${value} | ${url} |\n`;
    });

    markdown += `\n`;

    // Generated Script
    if (script) {
      markdown += `## Generated Test Script\n\n`;
      markdown += `\`\`\`${this.getLanguageForMarkdown(framework)}\n`;
      markdown += script;
      markdown += `\n\`\`\`\n\n`;
    }

    // Network Requests Summary
    if (data.networkRequests && data.networkRequests.length > 0) {
      markdown += `## Network Activity\n\n`;
      markdown += `**Total Requests:** ${data.networkRequests.length}\n\n`;

      const requestsByType = this.groupRequestsByType(data.networkRequests);
      markdown += `**Requests by Type:**\n`;
      Object.entries(requestsByType).forEach(([type, count]) => {
        markdown += `- ${type}: ${count}\n`;
      });
      markdown += `\n`;
    }

    // Test Execution Instructions
    markdown += `## Execution Instructions\n\n`;
    markdown += this.getExecutionInstructions(framework);

    return {
      content: markdown,
      filename: this.generateFilename('flowscribe-test', 'md', options),
      mimeType: 'text/markdown'
    };
  }

  /**
   * Export to HTML format (visual test report)
   */
  exportToHTML(data, options = {}) {
    const actions = data.actions || [];
    const framework = data.framework || 'playwright';
    const script = data.script || '';

    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowScribe Test Report</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header .meta {
            opacity: 0.9;
            font-size: 14px;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e1e4e8;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .stat-card .label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-top: 5px;
        }

        .actions-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .actions-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
        }

        .actions-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }

        .actions-table tr:hover {
            background: #f8f9fa;
        }

        .action-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .action-type.click { background: #e3f2fd; color: #1976d2; }
        .action-type.input { background: #f3e5f5; color: #7b1fa2; }
        .action-type.navigate { background: #e8f5e9; color: #388e3c; }
        .action-type.change { background: #fff3e0; color: #f57c00; }

        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .footer {
            background: #f8f9fa;
            padding: 20px 40px;
            text-align: center;
            color: #6c757d;
            font-size: 14px;
        }

        @media print {
            body { background: white; padding: 0; }
            .container { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“„ FlowScribe Test Report</h1>
            <div class="meta">
                Generated: ${new Date().toLocaleString()} | Framework: ${framework}
            </div>
        </div>

        <div class="content">
            <div class="stats">
                <div class="stat-card">
                    <div class="label">Total Actions</div>
                    <div class="value">${actions.length}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Framework</div>
                    <div class="value" style="font-size: 24px;">${framework}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Export Date</div>
                    <div class="value" style="font-size: 16px;">${new Date().toLocaleDateString()}</div>
                </div>
            </div>

            <div class="section">
                <h2>Recorded Actions</h2>
                <table class="actions-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Action</th>
                            <th>Element</th>
                            <th>Value</th>
                            <th>URL</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${actions.map((action, index) => {
                          const element = action.element || action.target || {};
                          return `
                            <tr>
                                <td>${index + 1}</td>
                                <td><span class="action-type ${action.type}">${action.type}</span></td>
                                <td>${this.htmlEscape(this.getElementDescription(element))}</td>
                                <td>${this.htmlEscape(action.value || '-')}</td>
                                <td style="font-size: 12px;">${this.htmlEscape(this.formatUrl(action.url) || '-')}</td>
                            </tr>
                          `;
                        }).join('')}
                    </tbody>
                </table>
            </div>

            ${script ? `
            <div class="section">
                <h2>Generated Test Script</h2>
                <pre class="code-block">${this.htmlEscape(script)}</pre>
            </div>
            ` : ''}
        </div>

        <div class="footer">
            Generated with FlowScribe - From Navigation to Automation
        </div>
    </div>
</body>
</html>`;

    return {
      content: html,
      filename: this.generateFilename('flowscribe-report', 'html', options),
      mimeType: 'text/html'
    };
  }

  // ===== Helper Methods =====

  /**
   * Get element description for display
   */
  getElementDescription(element) {
    if (!element) return 'N/A';

    if (element.textContent && element.textContent.trim()) {
      return element.textContent.trim().substring(0, 40);
    }
    if (element.placeholder) {
      return `[${element.placeholder}]`;
    }
    if (element.id) {
      return `#${element.id}`;
    }
    if (element.tagName) {
      return element.tagName.toLowerCase();
    }
    return 'element';
  }

  /**
   * Format URL for display
   */
  formatUrl(url) {
    if (!url) return null;
    try {
      const urlObj = new URL(url);
      return urlObj.pathname === '/' ? urlObj.hostname : `${urlObj.hostname}${urlObj.pathname}`;
    } catch {
      return url;
    }
  }

  /**
   * Format URL for Markdown (escape special characters)
   */
  formatUrlForMarkdown(url) {
    if (!url) return null;
    const formatted = this.formatUrl(url);
    return formatted ? formatted.replace(/[|]/g, '\\|') : null;
  }

  /**
   * Escape CSV cell content
   */
  csvEscape(cell) {
    const cellStr = String(cell);
    // Escape quotes and wrap in quotes if contains comma, newline, or quote
    if (cellStr.includes(',') || cellStr.includes('\n') || cellStr.includes('"')) {
      return `"${cellStr.replace(/"/g, '""')}"`;
    }
    return cellStr;
  }

  /**
   * Escape HTML special characters
   */
  htmlEscape(str) {
    const htmlEntities = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return String(str).replace(/[&<>"']/g, char => htmlEntities[char]);
  }

  /**
   * Get language identifier for Markdown code blocks
   */
  getLanguageForMarkdown(framework) {
    const languages = {
      playwright: 'javascript',
      selenium: 'java',
      cypress: 'javascript',
      puppeteer: 'javascript'
    };
    return languages[framework] || 'javascript';
  }

  /**
   * Group network requests by type
   */
  groupRequestsByType(requests) {
    const grouped = {};
    requests.forEach(req => {
      const type = req.type || 'other';
      grouped[type] = (grouped[type] || 0) + 1;
    });
    return grouped;
  }

  /**
   * Get execution instructions for framework
   */
  getExecutionInstructions(framework) {
    const instructions = {
      playwright: `### Prerequisites
\`\`\`bash
npm install @playwright/test
\`\`\`

### Run Test
\`\`\`bash
npx playwright test
\`\`\`

### Debug Mode
\`\`\`bash
npx playwright test --debug
\`\`\`
`,
      selenium: `### Prerequisites
- Java JDK 8+
- Maven or Gradle
- WebDriver (ChromeDriver, etc.)

### Run Test
\`\`\`bash
mvn test
\`\`\`
`,
      cypress: `### Prerequisites
\`\`\`bash
npm install cypress
\`\`\`

### Run Test
\`\`\`bash
npx cypress run
\`\`\`

### Open Cypress UI
\`\`\`bash
npx cypress open
\`\`\`
`,
      puppeteer: `### Prerequisites
\`\`\`bash
npm install puppeteer
\`\`\`

### Run Test
\`\`\`bash
node test.js
\`\`\`
`
    };

    return instructions[framework] || instructions.playwright;
  }

  /**
   * Generate filename with timestamp
   */
  generateFilename(baseName, extension, options = {}) {
    const timestamp = options.includeTimestamp !== false
      ? `-${new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)}`
      : '';

    return `${baseName}${timestamp}.${extension}`;
  }

  /**
   * Download file to user's system
   */
  downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
  }

  /**
   * Export and download in one step
   */
  exportAndDownload(data, format, options = {}) {
    const exported = this.exportData(data, format, options);
    this.downloadFile(exported.content, exported.filename, exported.mimeType);
    return exported.filename;
  }
}

// Export for use in extension
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ExportManager;
} else {
  window.ExportManager = ExportManager;
}
